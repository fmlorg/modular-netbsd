# nbpkg-build インターナル: basepkg 配布システムの裏側

## 問題の根幹

これは、はっきりしていて、ユーザランドの構成法に由来します。
数千個部品を組み上げるのか？
一つのソースコードから作成しているのか？
これは一種のトップダウン対ボトムアップという構図です。

Linuxのインストールは数千個のパッケージを入れて構成しています。
つまりユーザランドは etc-password-1.0 bin-ls-2.0 などの集合体で、
このインストール情報がパッケージとして管理できています。

一方 BSD Unixでは、まるっとNetBSD 8.0の配布物などとなってしまうので、
ユーザランドの部品の区別がありません。
あえていえば
etc-password-8.0 bin-ls-8.0 などといった表記法になるのかもしれませんが、
現在の /bin/ls が NetBSD 8.0 release なのか、
それとも netbsd-8 からビルドした版なのか？を知る汎用的な方法がありません。

NetBSD 8.0 から新登場した sys_info (/usr/bin/sys_info by agc@)
が一部教えてくれますが、/etc/passwd や ls のバージョンなどは分かりません。


## 暫定案

### 基準点、バージョン番号、差分の把握

* 公式メジャーリリースを基点とします。つまり基準点を、こちらで決めます。
    * basepkg パッケージのバージョンは「8.0.日付」とします。
       この日付は daily build が実行された日です。
       よって、
       base-sys-root-8.0.20181101.tgz などいうパッケージ名になります。
* 基準との差分を、どのようにして知るのか？というと ident 情報です。


### 維持管理する情報

生成システムが追跡するべき情報は次の二つです。
*   ident 情報: メジャーリリースおよび daily build の ident 履歴
* basepkg 情報: リリースした basepkg の履歴


### サーバ側での動作(配布パッケージの作成時)

作成するマスタープロセス nbpkg-build 側で、basepkg に指示を与えます。

1. ident情報に基づき daily build にアップデートがあったかを検査
    1. 変化がない場合、終了

1. 設定の準備
    1. daily build のident情報一覧を作成、保存
        1. 維持管理している情報その１：identの一覧
	   メジャーリリースおよび daily build の履歴を維持管理。
	   daily build の変化がある際に更新。
	   ファイルに保存されている情報は生成済み分のident最新情報。
	   例: /var/nbpkg-build/db/ident/netbsd-8/i386
    1. 変化した basepkg の一覧を作成
    1. basepkg の作成履歴も更新(依存関係)
        1. 維持管理している情報その２：リリースしたbasepkg一覧
	   identにもとづいて何らかの変化があったパッケージのみを作成。
	   ジャーナル型で複数回リリースがあったならそれらの全履歴を含む。
	   ```
	   base-sys-util  8.0.20181001
	   base-sys-shlib 8.0.20181001
	      ...
	   base-sys-util  8.0.20181020
	      ... 
	   ```
	   例: /var/nbpkg-build/db/basepkg/netbsd-8/i386
    1. basepkg に、これら二つの情報から生成した設定を渡し、
       必要なパッケージのみを作成。netbsd-8 ブランチを例に取ると
       渡している情報は次のとおりです。
       + 今回作成するべきパッケージの一覧 e.g. "base-sys-root 20181101",...
         (今回 netbsd-8 ブランチで変化があったパッケージの一覧)
       + 過去に作成したパッケージ一覧     e.g. "base-sys-root 20181101",...
         (8.0 リリースの1000+個と今までにnetbsd-8で変化があったパッケージ群)
       + build_id                         e.g. 8.0.20181101
       + build_date                       e.g.     20181101
       + build_target			       daily

    1. NetBSD 8.0 などのメジャーリリースに対しても basepkg パッケージ
       を用意しています。
       これは、
       ミニマム状態から nbpkg.sh -a で好きなパッケージだけを追加すると
       きに使うパッケージ群が依存関係の都合上 8.0 release などを必要と
       する場合に備えて用意しています。

       nbpkg-build -b release-8 を実行すると、
       8.0 リリースのパッケージ群を生成します。
       (管理者向けの注意)メジャーリリースの際には、まずこれを実行し、
       そのあと daily モードを動かすようにしなければならないわけです。

       (この名称は本当のところ間違っていますが) release-8 ブランチでは、
         build_target変数でリリースモードであることを教えるようにしています。
	 basepkgに今回は依存関係として">=8.0.20180717"を埋め込みつつ、
	 すべてのパッケージを作成を指示するためです。
       + 今回作成するべきパッケージの一覧 e.g. "base-*-* 20181101",...
       + 過去に作成したパッケージ一覧     
         (8.0 リリースの1000+個 e.g. "base-sys-root 20181101",...)
       + build_id                         e.g. 8.0.20180717
       + build_date                       e.g.     20180717
       + build_target			       release
   
1. basepkg 側にも手を入れて、
   nbpkg-build の指示で動く場合だけは、
   依存関係(@pkgdep)に手を入れながら、パッケージを作成する特別な挙動をします。
    1. 作成するものはident情報から判定し、
       @pkgdep は basepkg の作成履歴から依存情報を生成です。
       (上の例を使って説明すると) 20181130 に更新した comp-xxx-yyy が
       base-sys-shlib と base-sysutil に依存していた場合、
       パッケージには次のような依存情報が書き込まれます。
       ```
       @pkgdep base-sys-shlib>=8.0.20181001
       @pkgdep  base-sys-util>=8.0.20181020
       ```
       などとなります。
	   

### クライアント側の動作

pkgsrc のツール群を使うことを前提にしています。
リファレンス実装の nbpkg.sh は pkgin や pkg_add の単なる wrapper です。  

問題は、NetBSDにはインストールの基準点を参照する方法がないことです。
OS 上で、インストール情報が管理されていないので、
いま使っているシステムが
8.0 リリースなのか
8.0 stable の 20180801 版(自分でソースからビルドしたもの)
なのかも確実には分かりません。

依存性解決の案が二つあります。

1. /var/db/pkg に major official release のパッケージ情報を作成する案

   パッケージにも、その依存関係情報を入れるという方法がその１です。
   8.0リリース(2018/07/17にリリース)なら、
   8.0リリースから変化がないパッケージについても、
   ```
   @pkgdep package>=8.0.20180717
   ```
   などと書きこんでおくということです。
   
   クライアントで -a (もしくは -m all)を実行すると、
   こちらのモードで実行します。
   このモードでなら、ミニマムインストール(base と etc のみ)状態から
   ```
   nbpkg.sh -a comp-c-bin
   ```
   でCコンパイラをインストールすることが可能になります。
   極論を言えば、
   カーネルに少しずつ追加していくことで、
   小さいシステムの構築が容易になります。


1. パッケージ側の依存関係を操作して、
   メジャーリリース以降の依存関係だけを書いておく方法がその２です。
   
   クライアントでは、これがデフォルトモードです。

   この案の場合、
   /var/db/pkg が知っているのは
   pkgsrc と 8.0 stable で変更があった basepkg の情報分だけになります。

   たとえば 8.0 リリースをFull Installationしているなら、
   8.0.20180717
   のパッケージ1000個あまりがインストール済みと考えられます
   (これは暗黙の前提です。/var/db/pkg をみても分かりません)。

   このプランでは、各パッケージ内の**8.0 リリースへの依存関係**
   ```
   @pkgdep package>=8.0.20180717
   ```
   行は削除されています。
   例：
   ```
   @pkgdep base-sys-util>=8.0.20181111
   ```
   
   なぜ 8.0 総統を削除するのかというと、8.0リリースに相当する
   ```
   @pkgdep base-sys-root>=8.0.20180717
   ```
   行の情報が存在すると、
   /var/db/pkg
   を見に行き、それが存在しないことを発見してしまいます。
   その結果、アップデートする必要のない
   base-sys-root
   もインストールしようとしてしまうからです。



## 履歴: プランAとプランB

方針を受けて、プランBが現在の実装になっています。

最初に作成した プランA (JNUG 2018 NetBSD BoF で紹介した実装)は、
とにかく daily build から basepkg パッケージを作り、
クライアント側の設定でインストールするべきものを選択するという方式です。
設定は、セキュリティアドバイザリに従って誰かが作成するということになるので、
どうしても人の手が必要になってしまう運用に難のある方式です。

プランB は、ソースコードに埋められている ident 情報を見て、
変化のあった basepkg だけを作成するという案です。
海外ドラマでプランB というと、たいてい「行きあたりばったり」のことですが、
ここでは、ちゃんとした第２案です(w)。


## 謝辞

プランBは、
JNUG 2018 NetBSD BoFでの Onodera 案(ryoon@)にもとづいています。
議論に参加してくれた皆さん、ありがとうございます。
