# nbpkg-build インターナル: basepkg 配布システムの裏側

## 問題の根幹

これは、はっきりしていて、ユーザランドの構成法に由来します。
数千個部品を組み上げるのか？
一つのソースコードから作成しているのか？
これは一種のトップダウン対ボトムアップという構図です。

Linuxのインストールは数千個のパッケージを入れて構成しています。
つまりユーザランドは etc-password-1.0 bin-ls-2.0 などの集合体で、
それぞれにパッケージを作る担当者(複数の場合もある)がいます。
インストールしたパッケージの情報がディストリビューションの基本機能として管理されています。

一方 BSD Unixでは、
まるっと一式がNetBSD 8.0リリースの配布物などとなってしまうため、
ユーザランドの各部品のバージョン番号という考え方がありません。
あえてリリース番号をつければ
etc-password-8.0 bin-ls-8.0 などといった表記法になるのかもしれませんが、
そもそも論は、名前の付け方にあるのではなく
現在の /bin/ls が NetBSD 8.0 release なのか、
それとも netbsd-8 からビルドした版なのか？を知る汎用的な方法が
OSに用意されていません。

Linux ディストリビューションの場合、
各パッケージごとに作者やメインテイナーがいて、
彼らがバージョンをつけているわけですが、
NetBSD の場合、
netbsd-8 ブランチで pull up されたパッケージに、
いつ 8.0.1 とつけるべきなのか？を判断する汎用的な方法がありません。

NetBSD 8.0 から新登場した sys_info (/usr/bin/sys_info by agc@)
が一部教えてくれますが、/etc/passwd や ls のバージョンなどは分かりません。


## 暫定案

### 基準点、バージョン番号、差分の把握

- 公式メジャーリリースを基点とします。つまり基準点を、こちらで決めます。
    - basepkg パッケージのバージョンは「8.0.日付」とします。
       この日付は daily build が実行された日です。
       よって、
       base-sys-root-8.0.20181101.tgz などいうパッケージ名になります。
    - 備考: FreeBSD PkgBaseも日付ですね、だれが考えても、これしかないです
- 基準との差分を、どのようにして知るのか？というとmtreeないしはident情報です。
    - v0.6.0以降、mtreeをデフォルトにします。v0.2.0〜v0.5.0はidentでした。
    - /etc/mtree 以下の差分を取ります。
      ちなみに各tgz (e.g. base.tgz etc.tgz ...)には、
      それぞれの ./etc/mtree/set.カテゴリ (e.g.
      base.tgz には ./etc/mtree/set.base だけ、
      et.tgz   には ./etc/mtree/set.etc  だけ)
      が格納されています。
      つまり /etc/mtree を見ると、
      どのカテゴリだけをインストールしたのか?が分かるわけです。
      ちなみに /etc/mtree は 4.3BSD-reno で導入されました。
      この情報を元にOSが書き換えられていないか？の確認などが出来るわけで、
      もともとセキュリティチェックのためにあるような気がしますが、
      我々はインストール情報元として使っています。
    - identは、実際にユーザランドの全ファイルに対してidentコマンドを実行し、
      埋め込まれているident情報を収集し、前回との差分をみています。
      ident差分を追跡できれば、
      生成されたbasepkgの差分をソースレベルで表示することもできるので、
      この方法は理想だと思うのですが、
      あいにく、
      ただし確実にidentがあるのはCSRG由来の部分だけのようなので、
      部分的にしか動作しません。
        - CSRG 由来? sccs ないしは ident tagがあるソースコード
	- その後、追加されたとおもわれるソースコードには、
	    identがないものがあります。
	    追加するべきですね、いや、send-pr するべきですね。
    - どっちにしろ、全tarball(*.tgz)をダウンロードして展開する必要があります、
      と言うのは
        - mtree は /etc/mtree 以下を各tarballがそれぞれの分を持つため
	- ident は実際に展開してidentを取るため
    - 

### 維持管理する情報

生成システムが追跡するべき情報は次の二つです。
-   mtree 情報: メジャーリリースおよび daily build の mtree 履歴
-   ident 情報: メジャーリリースおよび daily build の ident 履歴 (obsolete)
- basepkg 情報: (本システムが)リリースした basepkg の履歴


### サーバ側での動作(配布パッケージの作成時)

作成するマスタープロセス nbpkg-build 側で、basepkg に指示を与えます。

1. (開始前にリリースを元に {mtree,ident} データベースの初期化作業)
    1. tarball(*.tgz)をダウンロード、展開し、情報を取り出す
        - mtree は展開した /etc/mtree/set.* から生成(cat)
	  (nbpkg-data/bin/nbpkg-mtreegen.sh ?)
        - ident は展開したユーザランドに全ファイルに対し ident を実行
	  (nbpkg-data/bin/nbpkg-identgen.sh)
    1. TODO: nbpkg-data/bin/nbpkg-*gen.sh は無くてもよくて、
             リリースモードでビルドした時に自動的に初期化すればよいはず:
	     $db_{ident,mtree}_dir/$arch = 
	     {/var/nbpkg-build/db/ident/, /var/nbpkg-build/db/mtree/}
	     
1. {mtree,ident}情報に基づき daily build にアップデートがあったかを検査
    1. 変化がない場合、終了

1. 設定の準備
    1. daily build の{mtree,ident}情報一覧を作成、保存
        1. tarball(*.tgz)をダウンロード、展開し、情報を取り出す
	   (上述の手順と同様)
        1. 維持管理している情報その１：{mtree,ident}の一覧
	   メジャーリリースおよび daily build の履歴を維持管理。
	   daily build の変化がある際に更新。
	   ファイルに保存されている情報は生成済み分の{mtree,ident}最新情報。
	   例: /var/nbpkg-build/db/{mtree,ident}/netbsd-8/i386
    1. 変化した basepkg の一覧を作成
    1. basepkg の作成履歴も更新(依存関係)
        1. 維持管理している情報その２：リリースしたbasepkg一覧
	   {mtree,ident}にもとづいて何らかの変化があったパッケージのみを作成。
	   ジャーナル型で複数回リリースがあったならそれらの全履歴を含む。
	   ```
	   base-sys-util  8.0.20181001
	   base-sys-shlib 8.0.20181001
	      ...
	   base-sys-util  8.0.20181020
	      ... 
	   ```
	   例: /var/nbpkg-build/db/basepkg/netbsd-8/i386
    1. basepkg に、これら二つの情報から生成した設定を渡し、
       必要なパッケージのみを作成。netbsd-8 ブランチを例に取ると
       渡している情報は次のとおりです。
       + 今回作成するべきパッケージの一覧 e.g. "base-sys-root 20181101",...
         (今回 netbsd-8 ブランチで変化があったパッケージの一覧)
       + 過去に作成したパッケージ一覧     e.g. "base-sys-root 20181101",...
         (8.0 リリースの1000+個と今までにnetbsd-8で変化があったパッケージ群)
       + build_id                         e.g. 8.0.20181101
       + build_date                       e.g.     20181101
       + build_target			       daily

    1. NetBSD 8.0 などのメジャーリリースに対しても basepkg パッケージ
       を用意しています。
       これは、
       ミニマム状態から nbpkg.sh -a で好きなパッケージだけを追加すると
       きに使うパッケージ群が依存関係の都合上 8.0 release などを必要と
       する場合に備えて用意しています。

       nbpkg-build -b release-8 を実行すると、
       8.0 リリースのパッケージ群を生成します。
       (管理者向けの注意)メジャーリリースの際には、まずこれを実行し、
       そのあと daily モードを動かすようにしなければならないわけです。

       (この名称は本当のところ間違っていますが) release-8 ブランチでは、
         build_target変数でリリースモードであることを教えるようにしています。
	 basepkgに今回は依存関係として">=8.0.20180717"を埋め込みつつ、
	 すべてのパッケージを作成を指示するためです。
       + 今回作成するべきパッケージの一覧 e.g. "base-*-* 20181101",...
       + 過去に作成したパッケージ一覧     
         (8.0 リリースの1000+個 e.g. "base-sys-root 20181101",...)
       + build_id                         e.g. 8.0.20180717
       + build_date                       e.g.     20180717
       + build_target			       release
   
1. basepkg 側にも手を入れて、
   nbpkg-build の指示で動く場合だけは、
   依存関係(@pkgdep)に手を入れながら、パッケージを作成する特別な挙動をします。
    1. 作成するものは{mtree,ident}情報から判定し、
       @pkgdep は basepkg の作成履歴から依存情報を生成です。
       (上の例を使って説明すると) 20181130 に更新した comp-xxx-yyy が
       base-sys-shlib と base-sysutil に依存していた場合、
       パッケージには次のような依存情報が書き込まれます。
       ```
       @pkgdep base-sys-shlib>=8.0.20181001
       @pkgdep  base-sys-util>=8.0.20181020
       ```
       などとなります。
	   

### クライアント側の動作

pkgsrc のツール群を使うことを前提にしています。
リファレンス実装の nbpkg.sh は pkgin や pkg_add の単なる wrapper です。  

問題は、NetBSDにはインストールの基準点を参照する方法がないことです。
OS 上で、インストール情報が管理されていないので、
いま使っているシステムが
8.0 リリースなのか
8.0 stable の 20180801 版(自分でソースからビルドしたもの)
なのかも確実には分かりません。

依存性解決の案が二つあります。

1. /var/db/pkg に major official release のパッケージ情報を作成する案

   パッケージにも、その依存関係情報を入れるという方法がその１です。
   8.0リリース(2018/07/17にリリース)なら、
   8.0リリースから変化がないパッケージについても、
   ```
   @pkgdep package>=8.0.20180717
   ```
   などと書きこんでおくということです。
   
   クライアントで -a (もしくは -m all)を実行すると、
   こちらのモードで実行します。
   このモードでなら、ミニマムインストール(base と etc のみ)状態から
   ```
   nbpkg.sh -a comp-c-bin
   ```
   でCコンパイラをインストールすることが可能になります。
   極論を言えば、
   カーネルに少しずつ追加していくことで、
   小さいシステムの構築が容易になります。


1. パッケージ側の依存関係を操作して、
   メジャーリリース以降の依存関係だけを書いておく方法がその２です。
   
   クライアントでは、これがデフォルトモードです。

   この案の場合、
   /var/db/pkg が知っているのは
   pkgsrc と 8.0 stable で変更があった basepkg の情報分だけになります。

   たとえば 8.0 リリースをFull Installationしているなら、
   8.0.20180717
   のパッケージ1000個あまりがインストール済みと考えられます
   (これは暗黙の前提です。/var/db/pkg をみても分かりません)。

   このプランでは、各パッケージ内の**8.0 リリースへの依存関係**
   ```
   @pkgdep package>=8.0.20180717
   ```
   行は削除されています。
   例：
   ```
   @pkgdep base-sys-util>=8.0.20181111
   ```
   
   なぜ 8.0 総統を削除するのかというと、8.0リリースに相当する
   ```
   @pkgdep base-sys-root>=8.0.20180717
   ```
   行の情報が存在すると、
   /var/db/pkg
   を見に行き、それが存在しないことを発見してしまいます。
   その結果、アップデートする必要のない
   base-sys-root
   もインストールしようとしてしまうからです。



## 履歴: プランAとプランB

### プランB

方針を受けて、プランBが現在の実装になっています。

最初に作成した プランA (JNUG 2018 NetBSD BoF で紹介した実装)は、
とにかく daily build から basepkg パッケージを作り、
クライアント側の設定でインストールするべきものを選択するという方式です。
設定は、セキュリティアドバイザリに従って誰かが作成するということになるので、
どうしても人の手が必要になってしまう運用に難のある方式です。

プランB は、ソースコードに埋められている ident 情報を見て、
変化のあった basepkg だけを作成するという案です。
海外ドラマでプランB というと、たいてい「行きあたりばったり」のことですが、
ここでは、ちゃんとした第２案です(w)。

### 2018/12 運用版および修正

2018/12から運用・生成されているパッケージたちは、
github/fmlorg 側に fork してメンテしている
basepkg の  run/nbpkg-build-v0.3.0 ブランチを使ってビルドしています。

ところが arm など一部のターゲットが basepkg が動きません。
URLから割り出したアーキテクチャ名では
basepkg のターゲット判定ロジックがうまく識別できないようです。
basepkg 側で修正してもらったのですが、
以下の cherry-pick しても、うまく動いてない…
```
53789eca51ed1254862b0644873f4c17d02e3085
620f229d34ff08a91ecfbfd261f335dd81824b86
9d16b72d74b912bbe461c405366efad432c78297
b3777be222c8e54226496c8006e34d39ceecec18
6f50d3ed7b135f5a31ff270c1d6e462372431f07
```
それどころか、
元々の判定も出来なくなってしまった。あれ？

そういうわけで build.sh に元々あった ALIAS を使うほうがいいの？
この方法の方が確実に動作しているので、これにするか！

いや、そういう細かいシンクロではなく、
複数バージョンのbasepkgを広げて、
パス指定で切り替えてデバッグないし運用できるようにした方が楽な気がします。


## 謝辞

プランBは、
JNUG 2018 NetBSD BoFでの Onodera 案(ryoon@)にもとづいています。
議論に参加してくれた皆さん、ありがとうございます。
